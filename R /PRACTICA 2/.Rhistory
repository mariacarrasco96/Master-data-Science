alumnos$CALIFICACION[i]<-"Suspenso"
}
alumnos$Nota_FINAL<- alumnos$Nota_FINAL/100#para tener la nota sobre 10 hay q dividir entre 100
write.csv(alumnos, file =  "calificaciones ECO 2019-3.csv", row.names = FALSE)#se guardan todos los cambios realizadso en mi archivo csv
alumnos<-data.frame(calificaciones_ECO_2019_4)
alumnos_total<-length(alumnos$NOMBRE.ALUMNO) #para el total de alumnos
alumnos_total
mean(alumnos$Ex..JUNIO.12P,na.rm=TRUE)/100 #hay que dividir entre 100 para que de un resultado sobre 10
#Apartado B #se cogen solo los datos que queremos de la tabla que son los que hayan asistido a menos de un 50%de las clases y q hayan sacado mas de un 5 en el examen de junio
aprobadosasist<-alumnos[,c(1,7,8)]#se cogen las columnas
aprobadosasist<-subset(aprobadosasist, aprobadosasist$Asistencia..1P<50&aprobadosasist$Ex..JUNIO.12P>=500)#subset hace un subconjunto con las condiciones impuestas
print(aprobadosasist)
#Apartado C #se ejecutan distintos bucles con sus respectivas restricciones y se completa la tabla alumnos
for(i in 1:length(alumnos$NOMBRE.ALUMNO)){
if(alumnos$Nota_FINAL[i]>=500&alumnos$Nota_FINAL[i]<=699){
alumnos$CALIFICACION[i]<-"Aprobado"
}
}
for(i in 1:length(alumnos$NOMBRE.ALUMNO)){
if(alumnos$Nota_FINAL[i]>=700&alumnos$Nota_FINAL[i]<=899){
alumnos$CALIFICACION[i]<-"Notable"
}
}
for(i in 1:length(alumnos$NOMBRE.ALUMNO)){
if(alumnos$Nota_FINAL[i]>=900&alumnos$Nota_FINAL[i]<=1000)
alumnos$CALIFICACION[i]<-"Sobresaliente"
}
for(i in 1:length(alumnos$NOMBRE.ALUMNO)){ #este bucle se ejecuta para eliminar los NA de la tabla y que quede mas uniforme
if(alumnos$Nota_FINAL[i]>=0&alumnos$Nota_FINAL[i]<=499)
alumnos$CALIFICACION[i]<-"Suspenso"
}
alumnos$Nota_FINAL<- alumnos$Nota_FINAL/100#para tener la nota sobre 10 hay q dividir entre 100
write.csv(alumnos, file =  "calificaciones ECO 2019-4.csv", row.names = FALSE)#se guardan todos los cambios realizadso en mi archivo csv
#Apartado B #se cogen solo los datos que queremos de la tabla que son los que hayan asistido a menos de un 50%de las clases y q hayan sacado mas de un 5 en el examen de junio
aprobadosasist<-alumnos[,c(1,7,8)]#se cogen las columnas
aprobadosasist<-subset(aprobadosasist, aprobadosasist$Asistencia..1P<50&aprobadosasist$Ex..JUNIO.12P>=500)#subset hace un subconjunto con las condiciones impuestas
print(aprobadosasist)
#Apartado C #se ejecutan distintos bucles con sus respectivas restricciones y se completa la tabla alumnos
for(i in 1:length(alumnos$NOMBRE.ALUMNO)){
if(alumnos$Nota_FINAL[i]>=500&alumnos$Nota_FINAL[i]<=699){
alumnos$CALIFICACION[i]<-"Aprobado"
}
}
for(i in 1:length(alumnos$NOMBRE.ALUMNO)){
if(alumnos$Nota_FINAL[i]>=700&alumnos$Nota_FINAL[i]<=899){
alumnos$CALIFICACION[i]<-"Notable"
}
}
for(i in 1:length(alumnos$NOMBRE.ALUMNO)){
if(alumnos$Nota_FINAL[i]>=900&alumnos$Nota_FINAL[i]<=1000)
alumnos$CALIFICACION[i]<-"Sobresaliente"
}
for(i in 1:length(alumnos$NOMBRE.ALUMNO)){ #este bucle se ejecuta para eliminar los NA de la tabla y que quede mas uniforme
if(alumnos$Nota_FINAL[i]>=0&alumnos$Nota_FINAL[i]<=499)
alumnos$CALIFICACION[i]<-"Suspenso"
}
alumnos$Nota_FINAL<- alumnos$Nota_FINAL/100#para tener la nota sobre 10 hay q dividir entre 100
write.csv(alumnos, file =  "calificaciones ECO 2019-4.csv", row.names = FALSE)#se guardan todos los cambios realizadso en mi archivo csv
write.csv(alumnos, file =  "calificaciones ECO 2019-4.csv", row.names = FALSE)#se guardan todos los cambios realizadso en mi archivo csv
write.csv(alumnos, file =  "calificaciones ECO 2019-4.csv", row.names = FALSE)#se guardan todos los cambios realizadso en mi archivo csv
alumnos<-data.frame(calificaciones_ECO_2019_4)
alumnos_total<-length(alumnos$NOMBRE.ALUMNO) #para el total de alumnos
alumnos_total
mean(alumnos$Ex..JUNIO.12P,na.rm=TRUE)/100 #hay que dividir entre 100 para que de un resultado sobre 10
#Apartado B #se cogen solo los datos que queremos de la tabla que son los que hayan asistido a menos de un 50%de las clases y q hayan sacado mas de un 5 en el examen de junio
aprobadosasist<-alumnos[,c(1,7,8)]#se cogen las columnas
aprobadosasist<-subset(aprobadosasist, aprobadosasist$Asistencia..1P<50&aprobadosasist$Ex..JUNIO.12P>=500)#subset hace un subconjunto con las condiciones impuestas
print(aprobadosasist)
#Apartado C #se ejecutan distintos bucles con sus respectivas restricciones y se completa la tabla alumnos
for(i in 1:length(alumnos$NOMBRE.ALUMNO)){
if(alumnos$Nota_FINAL[i]>=500&alumnos$Nota_FINAL[i]<=699){
alumnos$CALIFICACION[i]<-"Aprobado"
}
}
for(i in 1:length(alumnos$NOMBRE.ALUMNO)){
if(alumnos$Nota_FINAL[i]>=700&alumnos$Nota_FINAL[i]<=899){
alumnos$CALIFICACION[i]<-"Notable"
}
}
for(i in 1:length(alumnos$NOMBRE.ALUMNO)){
if(alumnos$Nota_FINAL[i]>=900&alumnos$Nota_FINAL[i]<=1000)
alumnos$CALIFICACION[i]<-"Sobresaliente"
}
for(i in 1:length(alumnos$NOMBRE.ALUMNO)){ #este bucle se ejecuta para eliminar los NA de la tabla y que quede mas uniforme
if(alumnos$Nota_FINAL[i]>=0&alumnos$Nota_FINAL[i]<=499)
alumnos$CALIFICACION[i]<-"Suspenso"
}
alumnos$Nota_FINAL<- alumnos$Nota_FINAL/100#para tener la nota sobre 10 hay q dividir entre 100
write.csv(alumnos, file =  "calificaciones ECO 2019-4.csv", row.names = FALSE)#se guardan todos los cambios realizadso en mi archivo csv
alumnos<-data.frame(calificaciones_ECO_2019_4)
alumnos_total<-length(alumnos$NOMBRE.ALUMNO) #para el total de alumnos
alumnos_total
mean(alumnos$Ex..JUNIO.12P,na.rm=TRUE)/100 #hay que dividir entre 100 para que de un resultado sobre 10
#Apartado B #se cogen solo los datos que queremos de la tabla que son los que hayan asistido a menos de un 50%de las clases y q hayan sacado mas de un 5 en el examen de junio
aprobadosasist<-alumnos[,c(1,7,8)]#se cogen las columnas
aprobadosasist<-subset(aprobadosasist, aprobadosasist$Asistencia..1P<50&aprobadosasist$Ex..JUNIO.12P>=500)#subset hace un subconjunto con las condiciones impuestas
print(aprobadosasist)
#Apartado C #se ejecutan distintos bucles con sus respectivas restricciones y se completa la tabla alumnos
for(i in 1:length(alumnos$NOMBRE.ALUMNO)){
if(alumnos$Nota_FINAL[i]>=500&alumnos$Nota_FINAL[i]<=699){
alumnos$CALIFICACION[i]<-"Aprobado"
}
}
for(i in 1:length(alumnos$NOMBRE.ALUMNO)){
if(alumnos$Nota_FINAL[i]>=700&alumnos$Nota_FINAL[i]<=899){
alumnos$CALIFICACION[i]<-"Notable"
}
}
for(i in 1:length(alumnos$NOMBRE.ALUMNO)){
if(alumnos$Nota_FINAL[i]>=900&alumnos$Nota_FINAL[i]<=1000)
alumnos$CALIFICACION[i]<-"Sobresaliente"
}
for(i in 1:length(alumnos$NOMBRE.ALUMNO)){ #este bucle se ejecuta para eliminar los NA de la tabla y que quede mas uniforme
if(alumnos$Nota_FINAL[i]>=0&alumnos$Nota_FINAL[i]<=499)
alumnos$CALIFICACION[i]<-"Suspenso"
}
alumnos$Nota_FINAL<- alumnos$Nota_FINAL/100#para tener la nota sobre 10 hay q dividir entre 100
write.csv(alumnos, file =  "calificaciones ECO 2019-4.csv", row.names = FALSE)#se guardan todos los cambios realizadso en mi archivo csv
write.csv(alumnos, file =  "calificaciones ECO 2019-4.csv", row.names = FALSE)#se guardan todos los cambios realizadso en mi archivo csv
alumnos<-data.frame(calificaciones_ECO_2019_4)
alumnos_total<-length(alumnos$NOMBRE.ALUMNO) #para el total de alumnos
alumnos_total
mean(alumnos$Ex..JUNIO.12P,na.rm=TRUE)/100 #hay que dividir entre 100 para que de un resultado sobre 10
#Apartado B #se cogen solo los datos que queremos de la tabla que son los que hayan asistido a menos de un 50%de las clases y q hayan sacado mas de un 5 en el examen de junio
aprobadosasist<-alumnos[,c(1,7,8)]#se cogen las columnas
aprobadosasist<-subset(aprobadosasist, aprobadosasist$Asistencia..1P<50&aprobadosasist$Ex..JUNIO.12P>=500)#subset hace un subconjunto con las condiciones impuestas
print(aprobadosasist)
#Apartado C #se ejecutan distintos bucles con sus respectivas restricciones y se completa la tabla alumnos
for(i in 1:length(alumnos$NOMBRE.ALUMNO)){
if(alumnos$Nota_FINAL[i]>=500&alumnos$Nota_FINAL[i]<=699){
alumnos$CALIFICACION[i]<-"Aprobado"
}
}
for(i in 1:length(alumnos$NOMBRE.ALUMNO)){
if(alumnos$Nota_FINAL[i]>=700&alumnos$Nota_FINAL[i]<=899){
alumnos$CALIFICACION[i]<-"Notable"
}
}
for(i in 1:length(alumnos$NOMBRE.ALUMNO)){
if(alumnos$Nota_FINAL[i]>=900&alumnos$Nota_FINAL[i]<=1000)
alumnos$CALIFICACION[i]<-"Sobresaliente"
}
for(i in 1:length(alumnos$NOMBRE.ALUMNO)){ #este bucle se ejecuta para eliminar los NA de la tabla y que quede mas uniforme
if(alumnos$Nota_FINAL[i]>=0&alumnos$Nota_FINAL[i]<=499)
alumnos$CALIFICACION[i]<-"Suspenso"
}
alumnos$Nota_FINAL<- alumnos$Nota_FINAL/100#para tener la nota sobre 10 hay q dividir entre 100
write.csv(alumnos, file =  "calificaciones ECO 2019-4.csv", row.names = FALSE)#se guardan todos los cambios realizadso en mi archivo csv
alumnos<-data.frame(calificaciones_ECO_2019_4)
alumnos_total<-length(alumnos$NOMBRE.ALUMNO) #para el total de alumnos
alumnos_total
mean(alumnos$Ex..JUNIO.12P,na.rm=TRUE)/100 #hay que dividir entre 100 para que de un resultado sobre 10
#Apartado B #se cogen solo los datos que queremos de la tabla que son los que hayan asistido a menos de un 50%de las clases y q hayan sacado mas de un 5 en el examen de junio
aprobadosasist<-alumnos[,c(1,7,8)]#se cogen las columnas
aprobadosasist<-subset(aprobadosasist, aprobadosasist$Asistencia..1P<50&aprobadosasist$Ex..JUNIO.12P>=500)#subset hace un subconjunto con las condiciones impuestas
print(aprobadosasist)
#Apartado C #se ejecutan distintos bucles con sus respectivas restricciones y se completa la tabla alumnos
for(i in 1:length(alumnos$NOMBRE.ALUMNO)){
if(alumnos$Nota_FINAL[i]>=500&alumnos$Nota_FINAL[i]<=699){
alumnos$CALIFICACION[i]<-"Aprobado"
}
}
for(i in 1:length(alumnos$NOMBRE.ALUMNO)){
if(alumnos$Nota_FINAL[i]>=700&alumnos$Nota_FINAL[i]<=899){
alumnos$CALIFICACION[i]<-"Notable"
}
}
for(i in 1:length(alumnos$NOMBRE.ALUMNO)){
if(alumnos$Nota_FINAL[i]>=900&alumnos$Nota_FINAL[i]<=1000)
alumnos$CALIFICACION[i]<-"Sobresaliente"
}
for(i in 1:length(alumnos$NOMBRE.ALUMNO)){ #este bucle se ejecuta para eliminar los NA de la tabla y que quede mas uniforme
if(alumnos$Nota_FINAL[i]>=0&alumnos$Nota_FINAL[i]<=499)
alumnos$CALIFICACION[i]<-"Suspenso"
}
alumnos$Nota_FINAL<- alumnos$Nota_FINAL/100#para tener la nota sobre 10 hay q dividir entre 100
write.csv(alumnos, file =  "calificaciones ECO 2019-4.csv", row.names = FALSE)#se guardan todos los cambios realizadso en mi archivo csv
write.csv(alumnos, file =  "calificaciones ECO 2019-4.csv", row.names = FALSE)#se guardan todos los cambios realizadso en mi archivo csv
alumnos<-data.frame(calificaciones_ECO_2019_4)
alumnos_total<-length(alumnos$NOMBRE.ALUMNO) #para el total de alumnos
alumnos_total
mean(alumnos$Ex..JUNIO.12P,na.rm=TRUE)/100 #hay que dividir entre 100 para que de un resultado sobre 10
#Apartado B #se cogen solo los datos que queremos de la tabla que son los que hayan asistido a menos de un 50%de las clases y q hayan sacado mas de un 5 en el examen de junio
aprobadosasist<-alumnos[,c(1,7,8)]#se cogen las columnas
aprobadosasist<-subset(aprobadosasist, aprobadosasist$Asistencia..1P<50&aprobadosasist$Ex..JUNIO.12P>=500)#subset hace un subconjunto con las condiciones impuestas
print(aprobadosasist)
#Apartado C #se ejecutan distintos bucles con sus respectivas restricciones y se completa la tabla alumnos
for(i in 1:length(alumnos$NOMBRE.ALUMNO)){
if(alumnos$Nota_FINAL[i]>=500&alumnos$Nota_FINAL[i]<=699){
alumnos$CALIFICACION[i]<-"Aprobado"
}
}
for(i in 1:length(alumnos$NOMBRE.ALUMNO)){
if(alumnos$Nota_FINAL[i]>=700&alumnos$Nota_FINAL[i]<=899){
alumnos$CALIFICACION[i]<-"Notable"
}
}
for(i in 1:length(alumnos$NOMBRE.ALUMNO)){
if(alumnos$Nota_FINAL[i]>=900&alumnos$Nota_FINAL[i]<=1000)
alumnos$CALIFICACION[i]<-"Sobresaliente"
}
for(i in 1:length(alumnos$NOMBRE.ALUMNO)){ #este bucle se ejecuta para eliminar los NA de la tabla y que quede mas uniforme
if(alumnos$Nota_FINAL[i]>=0&alumnos$Nota_FINAL[i]<=499)
alumnos$CALIFICACION[i]<-"Suspenso"
}
alumnos$Nota_FINAL<- alumnos$Nota_FINAL/100#para tener la nota sobre 10 hay q dividir entre 100
write.csv(alumnos, file =  "calificaciones ECO 2019-4.csv", row.names = FALSE)#se guardan todos los cambios realizadso en mi archivo csv
library(readr)
calificaciones_ECO_2019_5 <- read_delim("~/Downloads/calificaciones ECO 2019-5.csv",
";", escape_double = FALSE, col_types = cols(`Asistencia -1P` = col_number(),
`Media parcialitos` = col_number(),
`Nota Labs -2P` = col_number(), Nota_FINAL = col_number(),
`Parcialito 1-10P` = col_number()),
trim_ws = TRUE)
View(calificaciones_ECO_2019_5)
alumnos<-data.frame(calificaciones_ECO_2019_5)
alumnos_total<-length(alumnos$NOMBRE.ALUMNO) #para el total de alumnos
alumnos_total
mean(alumnos$Ex..JUNIO.12P,na.rm=TRUE)/100 #hay que dividir entre 100 para que de un resultado sobre 10
#Apartado B #se cogen solo los datos que queremos de la tabla que son los que hayan asistido a menos de un 50%de las clases y q hayan sacado mas de un 5 en el examen de junio
aprobadosasist<-alumnos[,c(1,7,8)]#se cogen las columnas
aprobadosasist<-subset(aprobadosasist, aprobadosasist$Asistencia..1P<50&aprobadosasist$Ex..JUNIO.12P>=500)#subset hace un subconjunto con las condiciones impuestas
print(aprobadosasist)
#Apartado C #se ejecutan distintos bucles con sus respectivas restricciones y se completa la tabla alumnos
for(i in 1:length(alumnos$NOMBRE.ALUMNO)){
if(alumnos$Nota_FINAL[i]>=500&alumnos$Nota_FINAL[i]<=699){
alumnos$CALIFICACION[i]<-"Aprobado"
}
}
for(i in 1:length(alumnos$NOMBRE.ALUMNO)){
if(alumnos$Nota_FINAL[i]>=700&alumnos$Nota_FINAL[i]<=899){
alumnos$CALIFICACION[i]<-"Notable"
}
}
for(i in 1:length(alumnos$NOMBRE.ALUMNO)){
if(alumnos$Nota_FINAL[i]>=900&alumnos$Nota_FINAL[i]<=1000)
alumnos$CALIFICACION[i]<-"Sobresaliente"
}
for(i in 1:length(alumnos$NOMBRE.ALUMNO)){ #este bucle se ejecuta para eliminar los NA de la tabla y que quede mas uniforme
if(alumnos$Nota_FINAL[i]>=0&alumnos$Nota_FINAL[i]<=499)
alumnos$CALIFICACION[i]<-"Suspenso"
}
alumnos$Nota_FINAL<- alumnos$Nota_FINAL/100#para tener la nota sobre 10 hay q dividir entre 100
write.csv(alumnos, file =  "calificaciones ECO 2019-4.csv", row.names = FALSE)#se guardan todos los cambios realizadso en mi archivo csv
View(alumnos)
View(alumnos)
return(m)
nternas<-function(n) {
if (n < 1) {
return("Selecciona valores mayor o igual a 1")
}
else
cuaternaf<-c(fibonacci(n+4))
m<-matrix(nrow = n, ncol = 3)
for (i in 1:n){
v1<-cuaternaf[(i+1)]
v2<-cuaternaf[(i+2)]
v3<-cuaternaf[(i+3)]
v4<-cuaternaf[(i+4)]
a<-v1*v4
b<-2*v2*v3
h<-(v2*v2)+(v3*v3)
m[i, ]<-c(a,b,h)
}
return(m)
}
nternas<-function(n) {
if (n < 1) {
return("Selecciona valores mayor o igual a 1")
}
else
cuaternaf<-c(fibonacci(n+4))
m<-matrix(nrow = n, ncol = 3)
for (i in 1:n){
v1<-cuaternaf[(i+1)]
v2<-cuaternaf[(i+2)]
v3<-cuaternaf[(i+3)]
v4<-cuaternaf[(i+4)]
a<-v1*v4
b<-2*v2*v3
h<-(v2*v2)+(v3*v3)
m[i, ]<-c(a,b,h)
}
return(m)
}
nternas(6)
fibonacci<-function(n){
if(n<1){#no se pueden numeros negativos
return("escrine numeros enteros positivos")
}
if(n>0){#si n es mayor que 0 entonces..
sfibo<-seq(0,n)#haz una secuencia de 0 a n
for(i in 3:n){#y al llegar al tercer elemento
sfibo[i]<-sfibo[i-1]+sfibo[i-2]#machacamos sfib[i] por la siguiente expresion para q a partir del 3 todos los numeros que vengan detras sigan la secuencia fibonacci
}
return(sfibo)
}
}
fibonacci(20)
fibonacci(10)
nternas<-function(n) {
if (n < 1) {
return("Selecciona valores mayor o igual a 1")
}
else
cuaternaf<-c(fibonacci(n+4))
m<-matrix(nrow = n, ncol = 3)
for (i in 1:n){
v1<-cuaternaf[(i+1)]
v2<-cuaternaf[(i+2)]
v3<-cuaternaf[(i+3)]
v4<-cuaternaf[(i+4)]
a<-v1*v4
b<-2*v2*v3
h<-(v2*v2)+(v3*v3)
m[i, ]<-c(a,b,h)
}
return(m)
}
nternas(6)
install.packages("tidyverse")
library(tidyverse)
library(tidyverse)
mpg
data(mpg)
mpg
View(mpg)
View(mpg)
help(mpg)
facet_grid(dry¬ cyl)
ggplot(data=mpg) + geom_point(mapping = aes(x=drv y=cyl))
ggplot(data = mpg) + geom_point(mapping = aes(x=drv y=cyl))
ggplot(data = mpg) +
geom_point(mapping = aes(x=drv y=cyl, color=class)) +
facet_grid(drv¬cyl)
ggplot(data = mpg) +
geom_point(mapping = aes(x=drv y=cyl, color=class)) +
ggplot(data = mpg) +
geom_point(mapping = aes(x=drv y=cyl, color=class)) + #se ejecuta ahora sin el facet grid:traccion central es el q mas tiene cuatro tipos de cilindros
facet_grid(drv~cyl)
ggplot(data = mpg) +
geom_point(mapping = aes(x=drv y=cyl, color=class)) + #se ejecuta ahora sin el facet grid:traccion central es el q mas tiene cuatro tipos de cilindros
facet_grid(drv~cyl)
ggplot(data = mpg) +
geom_point(mapping = aes(x=drv, y=cyl, color=class)) + #se ejecuta ahora sin el facet grid:traccion central es el q mas tiene cuatro tipos de cilindros
facet_grid(drv~cyl)
ggplot(data = mpg) +
geom_point(mapping = aes(x=drv, y=cyl, color=class)) + #se ejecuta ahora sin el facet grid:traccion central es el q mas tiene cuatro tipos de cilindros
facet_grid(drv~cyl)
ggplot(data = mpg) +
geom_point(mapping = aes(x=drv, y=cyl, color=class)) + #se ejecuta ahora sin el facet grid:traccion central es el q mas tiene cuatro tipos de cilindros
facet_grid(drv~.)
ggplot(data = mpg) +
geom_point(mapping = aes(x=drv, y=cyl, color=class)) + #se ejecuta ahora sin el facet grid:traccion central es el q mas tiene cuatro tipos de cilindros
facet_grid(.~drv)
ggplot(data = mpg) +
geom_point(mapping = aes(x=drv, y=cyl, color=class)) + #se ejecuta ahora sin el facet grid:traccion central es el q mas tiene cuatro tipos de cilindros
facet_grid(drv~.)#este te lo pone por columnas, para poner la ondita es opt+ñ
ggplot(data = mpg) +
geom_point(mapping = aes(x=drv, y=cyl, color=class)) + #se ejecuta ahora sin el facet grid:traccion central es el q mas tiene cuatro tipos de cilindros
facet_grid(cyl~.)
ggplot(data = mpg) +
geom_point(mapping = aes(x=drv, y=cyl, color=class)) + #se ejecuta ahora sin el facet grid:traccion central es el q mas tiene cuatro tipos de cilindros
facet_grid(.~cyl)
ggplot(data=mpg)
geom_smooth(mapping = aes(x=displ, y=hwy, color=class))
ggplot(data=mpg)
geom_smooth(mapping = aes(x=displ, y=hwy, linetype=drv))
view(ggplot)
ggplot(data = mpg)+
geom_smooth(mapping = aes(x=displ, y=hwy, linetype=drv))
ggplot(data = mpg)+
geom_smooth(mapping = aes(x=displ, y=hwy, color=class))
warnings()
ggplot(data = mpg, mapping = aes( = displ, y = hwy))+
geom_point(mapping = aes(color = class)) +
geom_smooth()
ggplot(data = mpg, mapping = aes(x = displ, y = hwy))+
geom_point(mapping = aes(color = class)) +
geom_smooth()
install.packages("nycflights13")
library(nycflights13)
tibble
tibble
flights
data(flights)
force(flights)
flights
View(flights)
View(flights)
filter(flights,month==1,day==1)
jan1<-filter(flights,month==1,day==1)
View(jan1)
View(jan1)
filter(flights, month==11 | month==12)
nov_dec<- filter(flights, month==11 | month==12)
filter(flights, !(arr_delay> 120 |dep_delay>120))
NA=NA
#Exercise 14:
filter(flights, arr_delay>=2)
filter(flights, dest==IAH | dest==HOU)
filter(flights, dest=="IAH" | dest=="HOU")
help(flights)
#D:
filter(flights, month==7| month==8 | month==9)
#Exercise 14:
#A
filter(flights, arr_delay>=120)
#B
filter(flights, dest=="IAH" | dest=="HOU")
#C
help(flights)
#D:
filter(flights, month==7| month==8 | month==9)
#E
filter(flights, arr_delay>=120, dep_delay<=0)
#G
filter(flights, dep_time>=0000,dep_time<=600)
#G
filter(flights, dep_time>=2400,dep_time<=600)
#G
filter(flights, dep_time>=2400 | dep_time>=000,dep_time<=600)
#2
dyplr
#2
dplyr
#2
dplyr
#2
filter(flights, between(dep_time, 000, 600))
#D:
filter(flights, month>=7 & month<=9)
#E
filter(flights, arr_delay>=120, dep_delay<=0)
#F
filter(flights, dep_delay>=60, dep_delay-arr_delay>30)
#3
is.na(flights$dep_time)
sum(is.na(flights$dep_time))
#D:
filter(flights, month>=7 & month<=9)
FALSERNA
FALSE&NA
NA^0
#tambien se usa -inf y +inf pero el prgrama no lo puede procesar
NA*0
flights_sml<-select(flights,year:day,ends_with("delay"),distance,air_time)
mutate(flights,gain=arr_delay-dep_delay,speed=distance/air_time*60)
View(flights_sml)
View(flights_sml)
View(flights)
mutate(flights_sml,gain=arr_delay-dep_delay,speed=distance/air_time*60)
View(flights_sml)
View(flights_sml)
(flights$air_time-(flights$arr_time-flights$dep_time))
h<-round(1650:100)
h
h<-round(1650:100)
m<-1650%%100
h*60+m
install.packages("markovchain")
#primero cargamos la libreria
library(markovchain)
estados<-c("soleado","nublado","lluvioso")
#primero cargamos la libreria
library(markovchain)
estados<-c("soleado","nublado","lluvioso")
byRow<-True
byRow<-TRUE
mt<- matrix(data= c(0,60,0,3,0,1,0,4,0,4,0,2,0.25,0.45,0.30), byRow = byRow,
nrow = 3,dinammes =list(estados,estados))
library(markovchain)
estados<-c("a","b","c")
byRow<-TRUE
mt<-matrix(data = c(630,28,42,105,570,75,55,44,451), byrow = byRow,
nrow = 3,dimnames = list(estados, estados)))
mt<-matrix(data = c(630/700,28/700,42/700,105/750,570/750,75/750,55/550,44/550,451/550), byrow = byRow,
nrow = 3,dimnames = list(estados, estados)))
mt<-matrix(data = c(630/700,28/700,42/700,105/750,570/750,75/750,55/550,44/550,451/550), byrow = byRow,
nrow = 3,dimnames = list(estados, estados))
mt
View(mt)
View(mt)
mes_marzo <- new("markovchain", states = estados, byrow = byRow,
transitionMatrix = mt, name = "marzo")
mes_marzo
plot(mes_marzo)
sinical<-(700/2000, 750/2000, 550/2000)
sinical<-c(700/2000, 750/2000, 550/2000)
marzo<-sinical*mt
View(marzo)
View(marzo)
cuota_mercado <- new("markovchain", states = estados, byrow = byRow,
transitionMatrix = mt, name = "marzo")
cuota_mercado
plot(cuota_mercado)
sinical<-c(700/2000, 750/2000, 550/2000)
marzo<-sinical*mes_marzo
View(marzo)
View(marzo)
marzo<-sinical*(cuota_mercado*cuota_mercado)
mayo<-sinicial*(cuota_mercado*4)
mayo<-sinicial*(cuota_mercado*4)
mayo<-sinicial*(cuota_mercado^4)
mayo<-sinicial*(cuota_mercado ^ 4)
sinical<-c(700/2000, 750/2000, 550/2000)
marzo<-sinical*(cuota_mercado ^ 1)
mayo<-sinicial*(cuota_mercado ^ 3)
sinicial<-c(700/2000, 750/2000, 550/2000)
marzo<-sinicial*(cuota_mercado ^ 1)
mayo<-sinicial*(cuota_mercado ^ 3)
View(mes_marzo)
